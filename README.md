# Load Balancer - балансировщик нагрузки 

## Инструкция по запуску

```bash
## Если есть утилита task:
task start
```

```bash
## Если нет утилиты task:

## 1) запуск фейковых серверов
go run cmd/servers/servers.go --servers=10 --start_port=8100 &

## 2) запуск postgresql в докере
docker compose up -d

## 3) запуск балансировщика нагрузки
go run cmd/loadBalancer/loadBalancer.go --path=config/config.yaml
```

**Запуск тестов:**

```bash
## Легкий тест:
ab -n 5000 -c 100 http://localhost:8080/

## Тяжелый тест
ab -n 20000 -c 1000 http://localhost:8080/
```

**Swagger**

Сваггер лежит в docs/swagger.yaml (сорян, сегодня без go-swagger)

## Описание проекта:

#### При запуске проекта:

1) Создаются фейковые сервера - по дефолту 10 штук, но это можно изменить с помощью флага, равно как и начальный порт для серверов;
2) Запускается postgresql в докере для сохранения конфигураций клиентов;
3) Запускается сам балансировщик нагрузки.

---

#### Что происходит внутри балансировщика нагрузки?

Одновременно функционируют три горутины:
    - основной поток программы;
    - горутина, отвечающая за health check всех бэкендов раз в interval времени;
    - горутина, отвечающая за пополнение токенов для клиентов раз в секунду.

## Реализованный функционал:

1) Reverse-proxy;
2) Алгоритм распределения запросов по бэкендам;
3) Логгирование;
4) Чтение конфигурационного файла, независимого от кода;
5) Корректная работа в условиях конкурентных вызовов;
6) Обработка ошибок
7) Реализация TokenBucket;
8) Хранение конфигураций клиентов в БД;
9) API для создания, удаления и получения конфига клиентов;
10) Graceful Shutdown;
11) Здоровье бэкендов (Health Checks);
12) Поддержка нескольких алгоритмов распределения;

## Конкурентность

1) atomic - доступность/недоступность бэкенда;
2) atomic - количество токенов у клиента;
3) подсчитывающий семафор - ограничение параллельности для healthCheck;
4) sync.Map - реализация локального кэша.

## Архитектура:

В коде я постарался использовать **трехслойную архитектуру** и все было супер до момента реализации кэша. Я буквально не знал, куда положить горутину для восполнения токенов, поэтому положил ее к другим функциям кэша - в storage/cache/clients.go. 

Интерфейсы располагал **по месту использования**. Внедрял инъекции зависимостей.