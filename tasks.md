# Tasks

## Часть 1. Балансировщик нагрузки

### Основной функционал:

* COMPLETE. Реализовать HTTP-сервер, который принимает входящие запросы (например, на порту 8080). 
* COMPLETE. При получении запроса балансировщик должен пересылать его на один из заранее заданных бэкенд-серверов. Адреса серверов можно задавать через конфигурационный файл или переменные окружения.
* COMPLETE. Использовать стандартный HTTP-пакет Go (net/http) для работы с запросами и для переадресации (reverse proxy, например, с использованием пакета net/http/httputil).

### Распределение запросов:

* COMPLETE. Реализовать алгоритм распределения запросов по бэкендам (минимум – round-robin).
* COMPLETE. Балансировщик должен корректно обрабатывать ситуацию, когда один или несколько бэкендов недоступны (выводить понятное сообщение об ошибке или перенаправлять запросы на работающие серверы).

### Параллелизм и конкурентность:

* COMPLETE. Обеспечить одновременную обработку нескольких запросов с использованием горутин.
* COMPLETE. Гарантировать корректную работу в условиях конкурентных вызовов (избегать гонок данных).

### Обработка ошибок:

* COMPLETE. Реализовать обработку ошибок при обращении к бэкендам.
* COMPLETE. Выводить понятные сообщения ошибок в лог (например, при недоступности сервера).

### Логирование:

* Реализовать базовое логирование входящих запросов, ошибок и событий (например, смены бэкенда при сбое одного из серверов). Можно использовать стандартный пакет log или другую библиотеку для логирования.

### Конфигурация:

* COMPLETE. Балансировщик должен получать список бэкендов и порт для прослушивания через внешний конфигурационный файл (JSON или YAML) или через параметры командной строки.
* COMPLETE. Конфигурация должна быть независима от кода (изменения конфигурации без перекомпиляции).

## Часть 2. Реализация Rate-Limiting
Требуется разработать модуль для ограничения частоты запросов (rate-limiting) на основе алгоритма Token Bucket. Модуль должен защищать внутренние сервисы от перегрузок, обеспечивать честное распределение ресурсов между клиентами и корректно обрабатывать высокую нагрузку.

Функциональные требования:

Реализация алгоритма Token Bucket:

Каждому клиенту (IP или API-ключ) выделяется отдельный bucket токенов.
Настройки bucket: количество токенов (емкость), скорость пополнения.
Запрос считается допустимым, если в bucket клиента есть токен. В противном случае — отклоняется.
Гранулярное ограничение:

Отслеживать состояние каждого клиента (IP/API-ключ)
Поддерживать возможность настройки разных лимитов для разных клиентов.
Настройки для разных клиентов можно сохранять в базе данных
Автоматическое пополнение токенов:

Использовать time.Ticker для периодического пополнения токенов в buckets.
Гарантировать атомарность операций с токенами (проверка, извлечение, пополнение).
Конкурентность:

Методы обработки запросов и обновления состояния buckets должны быть потокобезопасными.
Обеспечить минимальные блокировки для максимизации производительности.
Требуется подготовить README с описанием сборки и запуска проекта.

